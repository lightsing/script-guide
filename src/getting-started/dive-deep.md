# 深入了解

正如前文所描述的，不论是监听器还是卡牌都需要在适当的时候通过 `coroutine.yield` 返回并交出执行权。
那么何时才应当返回？

引擎的执行逻辑是：
1. 接收玩家的操作，并开始执行
2. 任何时候如果执行器通过 `coroutine.yield` 返回，开始处理返回的事件
3. 逐一检查每个事件是否有实体监听，若有，实例化监听器并执行
4. 返回第二步，直到没有执行器

这意味着，如果一个操作是不可以被打断的，例如一个实体攻击另一个实体（虽然你不需要写这部分代码）。
虽然顺次会产生多个事件，例如两个 `Death` 事件，你也不应该在每个事件一产生的时候就立刻通过 `coroutine.yield` 返回。
这样可能会导致意外的情况。
假设这部分的逻辑是这样的（伪代码表述）：
```lua
function attack(e1, e2)
    coroutine.yield(e2.takeDamage(e1.attack))
    coroutine.yield(e1.takeDamage(e2.attack))
end
```
第一行的 `takeDamage` 导致了 e2 实体的死亡，在 `coroutine.yield` 返回后，
引擎顺次检查死亡事件是否有实体在监听（例如亡语），
最后引擎从游戏中移除了 e2 实体，因为这个实体已经死亡。

接下来引擎将执行器还给 `attack`，此时 e1 受到 e2 的攻击力的伤害并死亡，但是会产生一个非法的事件！
在引擎看来，e1 死亡的伤害来源来自一个不存在的实体！

这里就是一个操作可不可以被打断的区别，如果它可以被打断，并且你现在产生了事件，那么你应该尽快通过 `coroutine.yield` 返回。
反之，如果多个操作之间是不可以打断的关系（计算机术语中也成为原子的（atomic）），那么你应当积攒其中的事件并在这些操作完成后一并返回。

修正后的伪代码是这样的：
```lua
function attack(e1, e2)
    coroutine.yield({ e2.takeDamage(e1.attack)，e1.takeDamage(e2.attack) })
end
```